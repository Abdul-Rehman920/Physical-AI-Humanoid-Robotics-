---
sidebar_position: 3
---

# Chapter 3: Building ROS 2 Python Packages

## Introduction

In the ROS 2 ecosystem, organizing your code into packages is fundamental for creating modular, reusable, and maintainable robotics applications. A well-structured package is not just a container for your code; it is a self-contained unit that clearly defines its purpose, dependencies, and build requirements. This modularity is crucial in robotics, where systems are often complex and composed of many interacting components. By encapsulating specific functionalities—such as sensor processing, motor control, or navigation logic—into distinct packages, developers can build robust systems that are easier to debug, test, and scale.

Proper package structure ensures that your project is interoperable with the broader ROS 2 ecosystem. It allows you to leverage a rich set of community-developed tools for building, testing, and deploying your code. When your package adheres to standard conventions, tools like `colcon` can automatically handle the build process, and `rosdep` can resolve system dependencies, streamlining your development workflow. Furthermore, a standardized structure makes it significantly easier for other developers to understand and contribute to your project. It establishes a clear and predictable layout, allowing anyone familiar with ROS 2 to quickly locate source code, launch files, and configuration. This chapter will guide you through the principles of creating and structuring ROS 2 Python packages, empowering you to build sophisticated robotics applications with clean, organized, and efficient code.

## ROS 2 Package Structure

A standard ROS 2 workspace is organized into several key directories, each with a specific role in the development lifecycle. At the top level is the **workspace** folder (e.g., `ros2_ws`), which serves as the primary container for your project. Inside the workspace, you will find the following directories:

- **`src`**: This is the source directory where you will store the source code for all your ROS 2 packages. Each package is a subdirectory within `src`, containing its own set of files and configurations. When you create a new package or clone an existing one from a repository, you place it here.

- **`build`**: This directory is automatically generated by `colcon`, the ROS 2 build tool. It contains intermediate files generated during the compilation process. For example, when building a Python package, `colcon` will create files that prepare your code for installation. You should never manually modify the contents of this folder.

- **`install`**: After a successful build, the `install` directory is created. It contains the final, installed versions of your packages. This includes executable scripts, shared libraries, launch files, and other resources needed to run your application. To make your executables and other package resources available in your environment, you need to source the `setup.bash` (or `setup.bat` on Windows) file located in this directory.

- **`log`**: This directory stores log files generated by ROS 2, which are invaluable for debugging. It contains records of past `colcon` builds and runtime node activity, providing detailed insights into the behavior of your system.

This standardized layout ensures a clean separation between your source code, build artifacts, and installed files, making project management straightforward and predictable.

## Creating Your First Package

Creating a new ROS 2 package is a simple process thanks to the `ros2 pkg create` command. This tool generates a boilerplate package structure with all the necessary configuration files, allowing you to get started quickly. Before creating a package, make sure you are in the `src` directory of your workspace.

To create a Python-based ROS 2 package, use the following command:

```bash
cd ~/ros2_ws/src
ros2 pkg create --build-type ament_python my_robot_pkg
```

Let's break down this command:
- **`ros2 pkg create`**: The main command to create a new package.
- **`--build-type ament_python`**: This flag specifies the build system to be used. For Python packages, `ament_python` is the standard choice. It configures the package to use Python's `setuptools` for building and installation.
- **`my_robot_pkg`**: This is the name of your new package.

After running the command, a new directory named `my_robot_pkg` will be created inside `src`. It will contain a `package.xml` file, a `setup.py` file, a `setup.cfg` file, and a directory with the same name as your package, which will house your Python modules.

## Package Configuration Files

### package.xml

The `package.xml` file is the manifest of your ROS 2 package. It contains critical metadata, such as the package name, version, description, and author. Most importantly, it defines the package's dependencies on other ROS 2 packages and system libraries.

Here is a complete example for a typical Python package:
```xml
<?xml version="1.0"?>
<package format="3">
  <name>my_robot_pkg</name>
  <version>0.0.0</version>
  <description>A package for controlling a robot.</description>
  <maintainer email="user@todo.todo">user</maintainer>
  <license>Apache License 2.0</license>

  <depend>rclpy</depend>
  <depend>std_msgs</depend>

  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>
```
In this file, the `<depend>` tags declare dependencies your package needs to build and run, such as `rclpy` (the ROS 2 Python client library) and `std_msgs` (for standard message types). The `<test_depend>` tags specify dependencies required only for testing. The `<export>` section declares the build type.

### setup.py

The `setup.py` file is the build script for your Python package. It uses the `setuptools` library to define how your package should be installed. It specifies which files to include, defines entry points for your executable nodes, and lists package metadata.

Here is a complete `setup.py` example:
```python
from setuptools import setup

package_name = 'my_robot_pkg'

setup(
    name=package_name,
    version='0.0.0',
    packages=[package_name],
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='user',
    maintainer_email='user@todo.todo',
    description='A package for controlling a robot.',
    license='Apache License 2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'robot_controller = my_robot_pkg.robot_controller:main',
        ],
    },
)
```
The `entry_points` dictionary is particularly important. It maps the desired executable name (`robot_controller`) to the Python function that should be run (`my_robot_pkg.robot_controller:main`). This makes your Python script runnable with `ros2 run`.

### setup.cfg

The `setup.cfg` file is a configuration file that provides additional instructions for the `setuptools` build system. It is often used to specify the directories where your executables and other scripts are located. When you create a Python package, a `setup.cfg` file is automatically generated. For a standard ROS 2 Python package, you typically don't need to modify it. It ensures that when you run `colcon build`, the build system knows where to find the entry points you defined in `setup.py`. For example, it will tell `colcon` that your executable scripts are located in the `my_robot_pkg` directory inside your package.

## Adding Python Nodes to Package

To add a Python node to your package, you create a Python file within the package's Python module (the subdirectory with the same name as the package). For example, you would create `my_robot_pkg/my_robot_pkg/robot_controller.py`.

A ROS 2 node is typically structured with a `main` function that initializes `rclpy`, creates an instance of your node class, and then spins the node to process callbacks.

The final step is to define an entry point in `setup.py` to make the node an executable. In the `entry_points` dictionary, you map the desired executable name to the location of your main function:
```python
'console_scripts': [
    'robot_controller = my_robot_pkg.robot_controller:main',
],
```
This tells ROS 2 that running `robot_controller` should execute the `main` function in `robot_controller.py`.

## Building with Colcon

`colcon` is the standard build tool for ROS 2. It automates the process of building and installing packages in your workspace. To build your package, navigate to the root of your workspace and run:

```bash
cd ~/ros2_ws
colcon build --packages-select my_robot_pkg
```

The `--packages-select` argument tells `colcon` to build only the specified package, which is useful in large workspaces. Once the build is complete, you need to source the `setup.bash` file in the `install` directory to make your package's executables available in your terminal session:

```bash
source install/setup.bash
```
Now you can run your node using `ros2 run my_robot_pkg robot_controller`. This command searches the ROS 2 environment for an executable named `robot_controller` in the `my_robot_pkg` package and runs it.

## Dependencies Management

Properly managing dependencies is crucial for creating portable and maintainable ROS 2 packages. Dependencies are declared in `package.xml`. When you add a new dependency, such as `sensor_msgs`, you add a `<depend>sensor_msgs</depend>` line.

To ensure all system dependencies are installed, you can use `rosdep`, a command-line tool that installs system libraries required by ROS 2 packages. To install dependencies for all packages in your `src` directory, run:
```bash
rosdep install -i --from-path src --rosdistro humble -y
```

## Best Practices

When developing ROS 2 packages, follow these best practices:
- **Code Organization**: Keep your code modular. Separate different functionalities into different files and classes.
- **Naming Conventions**: Use clear and consistent naming for your packages, nodes, topics, and services.
- **Documentation**: Document your code with comments and docstrings. Write a `README.md` file for your package to explain its purpose and usage.

## Complete Example: Robot Controller Package

To create a complete robot controller package, you would structure it with multiple nodes. For instance, you could have one node for reading sensor data (`sensor_node`) and another for controlling motors (`motor_node`). You would create separate Python files for each node inside your `my_robot_pkg` directory and add corresponding entry points in `setup.py`. This modular approach makes the system easier to manage and debug, as each node has a single, well-defined responsibility.

## Testing Your Package

Testing is a critical part of robotics software development. ROS 2 provides a framework for writing and running tests using `colcon test`. For Python packages, `pytest` is commonly used. You can add your tests to the `test` directory of your package. When you run `colcon test`, the framework will discover and execute your tests, reporting any failures. A basic test might check if your node can be launched successfully or if it publishes messages correctly.

## Review Questions

1. What is the purpose of the `src` directory in a ROS 2 workspace?
2. What information is stored in the `package.xml` file?
3. How do you make a Python script an executable ROS 2 node?
4. What command do you use to build a specific ROS 2 package?
5. What is the role of the `install` directory?
6. How do you add a dependency on the `sensor_msgs` package?
