"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[984],{8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var i=s(6540);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}},8892:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"module2-ros2/chapter2-communication-patterns","title":"Chapter 2: ROS 2 Communication Patterns","description":"Introduction","source":"@site/docs/module2-ros2/chapter2-communication-patterns.mdx","sourceDirName":"module2-ros2","slug":"/module2-ros2/chapter2-communication-patterns","permalink":"/Physical-AI-Humanoid-Robotics-/docs/module2-ros2/chapter2-communication-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module2-ros2/chapter2-communication-patterns.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1: ROS 2 Architecture and Core Concepts","permalink":"/Physical-AI-Humanoid-Robotics-/docs/module2-ros2/chapter1-architecture-core-concepts"},"next":{"title":"Chapter 3: Building ROS 2 Python Packages","permalink":"/Physical-AI-Humanoid-Robotics-/docs/module2-ros2/chapter3-python-packages-development"}}');var t=s(4848),r=s(8453);const o={sidebar_position:2},a="Chapter 2: ROS 2 Communication Patterns",c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Services: Request-Response Pattern",id:"services-request-response-pattern",level:2},{value:"Creating a Service Server",id:"creating-a-service-server",level:3},{value:"Creating a Service Client",id:"creating-a-service-client",level:3},{value:"Actions: Long-Running Tasks",id:"actions-long-running-tasks",level:2},{value:"Action Server Implementation",id:"action-server-implementation",level:3},{value:"Action Client Implementation",id:"action-client-implementation",level:3},{value:"Topics vs Services vs Actions",id:"topics-vs-services-vs-actions",level:2},{value:"Advanced Topic Features",id:"advanced-topic-features",level:2},{value:"Custom Interfaces",id:"custom-interfaces",level:2},{value:"Practical Project: Robot Control System",id:"practical-project-robot-control-system",level:2},{value:"Review Questions",id:"review-questions",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"chapter-2-ros-2-communication-patterns",children:"Chapter 2: ROS 2 Communication Patterns"})}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"In any distributed system, effective communication between different components is paramount. In robotics, where numerous processes often run concurrently across multiple machines, a well-defined and efficient communication architecture is even more crucial. ROS 2 provides a rich set of communication patterns that allow nodes to exchange information, request tasks, and coordinate complex behaviors. These patterns are built upon the Data Distribution Service (DDS) middleware, offering robust, scalable, and real-time capable communication. Understanding when and how to use each pattern\u2014Topics, Services, and Actions\u2014is key to designing flexible, modular, and maintainable ROS 2 applications. This chapter will delve into each of these fundamental communication paradigms, illustrating their use cases with practical examples and code snippets, and guiding you on how to choose the right tool for the right job in your robotics projects."}),"\n",(0,t.jsx)(n.h2,{id:"services-request-response-pattern",children:"Services: Request-Response Pattern"}),"\n",(0,t.jsxs)(n.p,{children:["While topics are ideal for streaming continuous data, there are many scenarios in robotics where a node needs to request a computation or a specific action from another node and then wait for a response. For these synchronous, request-response interactions, ROS 2 provides ",(0,t.jsx)(n.strong,{children:"Services"}),". Services are best used for operations that:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Have a clear start and end:"}),' e.g., "calculate inverse kinematics," "take a picture," "set a joint position."']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Require a response:"})," The client needs to know the outcome of the request before proceeding."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Are not high-frequency:"})," Services are generally not designed for continuous data streams like sensor readings."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["A service definition consists of two parts: a ",(0,t.jsx)(n.strong,{children:"request"})," message and a ",(0,t.jsx)(n.strong,{children:"response"})," message, separated by ",(0,t.jsx)(n.code,{children:"---"}),". For example, a simple service to add two integers might define its request as two integer fields and its response as a single integer sum field."]}),"\n",(0,t.jsx)(n.h3,{id:"creating-a-service-server",children:"Creating a Service Server"}),"\n",(0,t.jsx)(n.p,{children:'A service server is a node that "advertises" a service and waits for clients to call it. When a client makes a request, the server executes a callback function to process the request and send back a response.'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts # Standard service type for adding two integers\n\nclass MinimalService(Node):\n    def __init__(self):\n        super().__init__('minimal_service')\n        # Create a service server\n        # Arguments: Service type, service name, callback function\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\n        self.get_logger().info('AddTwoInts service is ready.')\n\n    def add_two_ints_callback(self, request, response):\n        # Process the request\n        response.sum = request.a + request.b\n        self.get_logger().info(f'Incoming request: a={request.a}, b={request.b}. Sum={response.sum}')\n        # Return the response\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_service = MinimalService()\n    rclpy.spin(minimal_service) # Keep the service running\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"creating-a-service-client",children:"Creating a Service Client"}),"\n",(0,t.jsx)(n.p,{children:"A service client is a node that sends a request to a service server and waits for its response. It needs to know the service type and name."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import sys\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy # For QoS\nfrom example_interfaces.srv import AddTwoInts\nfrom std_msgs.msg import String\n\nclass MinimalClient(Node):\n    def __init__(self):\n        super().__init__('minimal_client')\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n        \n        # Wait until the service is available\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n        self.req = AddTwoInts.Request()\n\n    def send_request(self, a, b):\n        self.req.a = a\n        self.req.b = b\n        # Call the service asynchronously\n        self.future = self.cli.call_async(self.req)\n        # Add a callback to process the response when it arrives\n        self.future.add_done_callback(self.response_callback)\n\n    def response_callback(self, future):\n        try:\n            response = future.result()\n            self.get_logger().info(f'Result of add_two_ints: {self.req.a} + {self.req.b} = {response.sum}')\n        except Exception as e:\n            self.get_logger().error(f'Service call failed: {e}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_client = MinimalClient()\n    \n    if len(sys.argv) == 3:\n        a = int(sys.argv[1])\n        b = int(sys.argv[2])\n        minimal_client.send_request(a, b)\n        rclpy.spin_until_future_complete(minimal_client, minimal_client.future)\n    else:\n        minimal_client.get_logger().info('Usage: ros2 run <package_name> minimal_client <a> <b>')\n    \n    minimal_client.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"actions-long-running-tasks",children:"Actions: Long-Running Tasks"}),"\n",(0,t.jsxs)(n.p,{children:["For long-running tasks that provide continuous feedback and can be preempted, ROS 2 offers ",(0,t.jsx)(n.strong,{children:"Actions"}),". Actions are a more complex communication pattern, built on top of topics and services, designed for goals that might take a significant amount of time to complete. Common use cases include:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Navigation:"}),' "Go to X, Y coordinates." (Feedback: current position, progress. Preemption: stop, change destination).']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Arm Manipulation:"}),' "Pick up object A and place it on B." (Feedback: arm position, grasping status. Preemption: abort if unexpected obstacle).']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Image Processing:"}),' "Process video stream for object detection." (Feedback: frames processed, objects detected. Preemption: stop processing).']}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"An action definition has three parts:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Goal:"})," The request to start the long-running task."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Result:"})," The outcome of the task upon completion."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Feedback:"})," Intermediate updates on the progress of the task."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"action-server-implementation",children:"Action Server Implementation"}),"\n",(0,t.jsx)(n.p,{children:"An action server receives goals from clients, executes the task, provides feedback, and sends a final result."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import time\nimport rclpy\nfrom rclpy.action import ActionServer\nfrom rclpy.node import Node\nfrom example_interfaces.action import Fibonacci # Example action type\n\nclass MinimalActionServer(Node):\n    def __init__(self):\n        super().__init__('minimal_action_server')\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            'fibonacci',\n            self.execute_callback)\n        self.get_logger().info('Fibonacci Action Server started.')\n\n    async def execute_callback(self, goal_handle):\n        self.get_logger().info('Executing goal...')\n\n        sequence = [0, 1]\n        for i in range(1, goal_handle.request.order):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info('Goal canceled.')\n                return Fibonacci.Result() # Return empty result\n            \n            sequence.append(sequence[i] + sequence[i-1])\n            \n            feedback_msg = Fibonacci.Feedback()\n            feedback_msg.sequence = sequence\n            goal_handle.publish_feedback(feedback_msg)\n            self.get_logger().info(f'Publishing feedback: {feedback_msg.sequence}')\n            time.sleep(1) # Simulate long-running task\n\n        goal_handle.succeed()\n        result = Fibonacci.Result()\n        result.sequence = sequence\n        self.get_logger().info(f'Goal succeeded. Result: {result.sequence}')\n        return result\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_action_server = MinimalActionServer()\n    rclpy.spin(minimal_action_server)\n    minimal_action_server.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"action-client-implementation",children:"Action Client Implementation"}),"\n",(0,t.jsx)(n.p,{children:"An action client sends a goal to an action server, receives feedback, and gets the final result."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\nfrom example_interfaces.action import Fibonacci # Example action type\n\nclass MinimalActionClient(Node):\n    def __init__(self):\n        super().__init__('minimal_action_client')\n        self._action_client = ActionClient(self, Fibonacci, 'fibonacci')\n        self.get_logger().info('Fibonacci Action Client created.')\n\n    def send_goal(self, order):\n        goal_msg = Fibonacci.Goal()\n        goal_msg.order = order\n\n        self.get_logger().info('Waiting for action server...')\n        self._action_client.wait_for_server()\n\n        self.get_logger().info(f'Sending goal request: order={order}')\n        self._send_goal_future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback)\n        \n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info('Goal rejected :(')\n            return\n\n        self.get_logger().info('Goal accepted :)')\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def get_result_callback(self, future):\n        result = future.result().result\n        self.get_logger().info(f'Result: {result.sequence}')\n        rclpy.shutdown()\n\n    def feedback_callback(self, feedback_msg):\n        self.get_logger().info(f'Received feedback: {feedback_msg.feedback.sequence}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_action_client = MinimalActionClient()\n    minimal_action_client.send_goal(10) # Request Fibonacci sequence up to order 10\n    rclpy.spin(minimal_action_client)\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"topics-vs-services-vs-actions",children:"Topics vs Services vs Actions"}),"\n",(0,t.jsx)(n.p,{children:"Choosing the correct communication pattern is crucial for designing efficient and robust ROS 2 applications. Here\u2019s a decision matrix and a table summarizing their typical use cases:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Pattern"}),(0,t.jsx)(n.th,{children:"Characteristics"}),(0,t.jsx)(n.th,{children:"Use Case"}),(0,t.jsx)(n.th,{children:"Example"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Topics"})}),(0,t.jsx)(n.td,{children:"Asynchronous, many-to-many, continuous streams, anonymous"}),(0,t.jsx)(n.td,{children:"Streaming continuous data, broadcasting information"}),(0,t.jsx)(n.td,{children:"Sensor readings (LIDAR, camera, IMU), Odometry updates, Robot state"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Services"})}),(0,t.jsx)(n.td,{children:"Synchronous, one-to-one, request-response, blocking"}),(0,t.jsx)(n.td,{children:"Requesting a single computation, performing a short-duration task with a definitive result"}),(0,t.jsx)(n.td,{children:"Get robot status, trigger a single action (e.g., open gripper), query a map"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Actions"})}),(0,t.jsx)(n.td,{children:"Asynchronous, one-to-one, goal-feedback-result, preemptable"}),(0,t.jsx)(n.td,{children:"Long-running tasks, tasks with intermediate feedback, tasks that can be cancelled or preempted"}),(0,t.jsx)(n.td,{children:"Navigate to a goal, pick-and-place operation, complex motion planning"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"When to choose which:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.strong,{children:"Topics"})," for data that is continuously generated and consumed, and where the publisher doesn't need to know if anyone is listening, nor does it expect a direct response."]}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.strong,{children:"Services"})," when you need to trigger a specific operation on another node and receive an immediate, one-time result. It's like a function call across nodes."]}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.strong,{children:"Actions"})," for tasks that are complex, take time to complete, require feedback on their progress, and might need to be canceled or modified mid-execution."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"advanced-topic-features",children:"Advanced Topic Features"}),"\n",(0,t.jsxs)(n.p,{children:["Beyond the basic publisher-subscriber model, ROS 2 topics offer advanced features through ",(0,t.jsx)(n.strong,{children:"Quality of Service (QoS) profiles"}),". QoS settings allow you to fine-tune the behavior of your communication channels to match the requirements of your application. The default QoS settings are suitable for many cases, but understanding how to adjust them is vital for optimizing performance and reliability."]}),"\n",(0,t.jsx)(n.p,{children:"Key QoS settings include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reliability:"})," Defines whether message delivery is guaranteed (",(0,t.jsx)(n.code,{children:"Reliable"}),") or if it's acceptable to lose some messages for lower latency (",(0,t.jsx)(n.code,{children:"Best Effort"}),"). ",(0,t.jsx)(n.code,{children:"Reliable"})," is used for critical data (e.g., robot commands), while ",(0,t.jsx)(n.code,{children:"Best Effort"})," is often used for high-frequency sensor data (e.g., camera images) where missing a frame is acceptable."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Durability:"})," Determines whether late-joining subscribers receive previously published messages (",(0,t.jsx)(n.code,{children:"Transient Local"}),") or only messages published after they subscribe (",(0,t.jsx)(n.code,{children:"Volatile"}),"). ",(0,t.jsx)(n.code,{children:"Transient Local"})," is useful for maps or configuration data that a new subscriber should immediately receive."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"History:"})," Controls how many messages are kept in memory (",(0,t.jsx)(n.code,{children:"Keep Last"})," N messages) or if all messages are kept (",(0,t.jsx)(n.code,{children:"Keep All"}),") up to a certain limit."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Liveliness:"})," Specifies how nodes declare their presence and how their absence is detected. This is crucial for detecting and reacting to unresponsive nodes."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These QoS settings are directly mapped to features of the underlying DDS implementation, providing powerful control over the communication middleware."}),"\n",(0,t.jsx)(n.h2,{id:"custom-interfaces",children:"Custom Interfaces"}),"\n",(0,t.jsxs)(n.p,{children:["While ROS 2 provides a rich set of standard message, service, and action types, you will frequently encounter situations where these are insufficient for your specific application. In such cases, ROS 2 allows you to define your own ",(0,t.jsx)(n.strong,{children:"custom interfaces"}),". This involves creating ",(0,t.jsx)(n.code,{children:".msg"})," (message), ",(0,t.jsx)(n.code,{children:".srv"})," (service), and ",(0,t.jsx)(n.code,{children:".action"})," (action) files within your ROS 2 packages."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:".msg"})," files:"]})," Define the structure of messages. They are simple text files where you list data types and field names, similar to defining a C++ struct or a Python class."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"# geometry_msgs/msg/Point.msg\nfloat64 x\nfloat64 y\nfloat64 z\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:".srv"})," files:"]})," Define the request and response structure for a service. The request and response fields are separated by ",(0,t.jsx)(n.code,{children:"---"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"# my_package/srv/CalculateArea.srv\nfloat64 length\nfloat64 width\n---\nfloat64 area\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:".action"})," files:"]})," Define the goal, result, and feedback structure for an action. The goal and result are separated by ",(0,t.jsx)(n.code,{children:"---"}),", and the result and feedback are separated by another ",(0,t.jsx)(n.code,{children:"---"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"# my_package/action/CountUp.action\nint32 target_number\n---\nint32 last_number\n---\nint32 current_number\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:'These custom interfaces are then "built" by the ROS 2 build system (ament), which generates corresponding code in various programming languages (e.g., Python, C++) that can be used in your nodes. This powerful feature ensures type safety and consistency across your distributed robotic system.'}),"\n",(0,t.jsx)(n.h2,{id:"practical-project-robot-control-system",children:"Practical Project: Robot Control System"}),"\n",(0,t.jsx)(n.p,{children:"To integrate your understanding of topics, services, and actions, consider building a simplified robot control system."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"robot_state_publisher"})," node (Topic Publisher):"]})," Publishes the robot's current joint angles and possibly its pose (",(0,t.jsx)(n.code,{children:"geometry_msgs/JointState"})," and ",(0,t.jsx)(n.code,{children:"geometry_msgs/PoseStamped"}),") to respective topics. This runs continuously."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"joint_controller"})," node (Topic Subscriber & Service Server):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Subscribes to ",(0,t.jsx)(n.code,{children:"/cmd_joint_position"})," topic to receive continuous desired joint positions."]}),"\n",(0,t.jsxs)(n.li,{children:["Offers a ",(0,t.jsx)(n.code,{children:"/set_single_joint_position"})," service that takes a ",(0,t.jsx)(n.code,{children:"joint_name"})," and ",(0,t.jsx)(n.code,{children:"position"})," as input and sets it, returning a boolean success. This is for one-off precise commands."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"gripper_control_action_server"})," node (Action Server):"]})," Provides a ",(0,t.jsx)(n.code,{children:"/close_gripper"})," action. The goal is ",(0,t.jsx)(n.code,{children:"target_force"}),". It provides feedback on current ",(0,t.jsx)(n.code,{children:"gripper_position"})," and returns ",(0,t.jsx)(n.code,{children:"success"})," in the result."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"task_commander"})," node (Service Client & Action Client):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Uses the ",(0,t.jsx)(n.code,{children:"/set_single_joint_position"})," service to move specific joints to a starting pose."]}),"\n",(0,t.jsxs)(n.li,{children:["Then sends a goal to the ",(0,t.jsx)(n.code,{children:"/close_gripper"})," action server, monitoring feedback until the gripper is closed with the target force."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This project demonstrates how these communication patterns work together to manage different aspects of robot control, from continuous data streams to discrete commands and long-running operations."}),"\n",(0,t.jsx)(n.h2,{id:"review-questions",children:"Review Questions"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Describe the primary use case for ROS 2 Services. How do they differ from Topics?"}),"\n",(0,t.jsx)(n.li,{children:"When would you choose to use a ROS 2 Action instead of a Service for a task? Provide an example."}),"\n",(0,t.jsx)(n.li,{children:"Explain the three components of a ROS 2 Action definition."}),"\n",(0,t.jsxs)(n.li,{children:["What are QoS profiles in ROS 2, and why are ",(0,t.jsx)(n.code,{children:"Reliable"})," and ",(0,t.jsx)(n.code,{children:"Best Effort"})," important for different types of data?"]}),"\n",(0,t.jsx)(n.li,{children:"How does ROS 2's architecture improve robustness compared to ROS 1?"}),"\n",(0,t.jsx)(n.li,{children:"Outline the steps you would take to create a custom ROS 2 message type for a new sensor."}),"\n",(0,t.jsxs)(n.li,{children:["In the context of the ",(0,t.jsx)(n.code,{children:"AddTwoInts"})," service example, what happens if the service server is not running when the client attempts to send a request?"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);